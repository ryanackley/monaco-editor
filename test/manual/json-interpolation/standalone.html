<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>JSON Interpolation - Standalone Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        h2 { margin-bottom: 10px; }
        .info {
            margin: 10px 0;
            padding: 10px;
            background: #2d2d2d;
            border-radius: 4px;
        }
        .info h3 { margin: 0 0 10px 0; }
        .info ul { margin: 5px 0; padding-left: 20px; }
        #container {
            width: 800px;
            height: 400px;
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <h2>JSON with Interpolation - Standalone Test</h2>

    <div class="info">
        <h3>Features to test:</h3>
        <ul>
            <li><strong>Syntax highlighting</strong>: Notice ${...} interpolations have JavaScript highlighting</li>
            <li><strong>Completions</strong>: Type inside ${} to see JavaScript completions for name, env, config, etc.</li>
            <li><strong>Hover</strong>: Hover over variables inside ${} for type info</li>
            <li><strong>Comments</strong>: // and /* */ comments are supported</li>
            <li><strong>Trailing commas</strong>: Trailing commas are allowed</li>
        </ul>
    </div>

    <div id="container"></div>

    <!-- Load Monaco from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.0/min/vs/loader.js"></script>
    <script>
        require.config({
            paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.0/min/vs' }
        });

        require(['vs/editor/editor.main'], function() {
            // --- Register json-interpolation language ---

            const LANGUAGE_ID = 'json-interpolation';

            // Register the language
            monaco.languages.register({
                id: LANGUAGE_ID,
                extensions: ['.jsonc', '.json5'],
                aliases: ['JSON with Interpolation', 'json-interpolation'],
                mimetypes: ['application/json-interpolation']
            });

            // Language configuration
            monaco.languages.setLanguageConfiguration(LANGUAGE_ID, {
                wordPattern: /(-?\d*\.\d\w*)|([^\[\{\]\}\:\"\,\s]+)/g,
                comments: {
                    lineComment: '//',
                    blockComment: ['/*', '*/']
                },
                brackets: [
                    ['{', '}'],
                    ['[', ']'],
                    ['${', '}']
                ],
                autoClosingPairs: [
                    { open: '{', close: '}' },
                    { open: '[', close: ']' },
                    { open: '"', close: '"', notIn: ['string'] },
                    { open: '${', close: '}' }
                ],
                surroundingPairs: [
                    { open: '{', close: '}' },
                    { open: '[', close: ']' },
                    { open: '"', close: '"' }
                ]
            });

            // Monarch tokenizer - simplified state machine
            // Uses flat structure to avoid state stack issues
            monaco.languages.setMonarchTokensProvider(LANGUAGE_ID, {
                defaultToken: '',
                tokenPostfix: '.json-interpolation',
                escapes: /\\(?:["\\/bfnrt]|u[0-9A-Fa-f]{4})/,

                tokenizer: {
                    root: [
                        { include: '@whitespace' },
                        { include: '@value' }
                    ],

                    whitespace: [
                        [/[ \t\r\n]+/, ''],
                        [/\/\/.*$/, 'comment'],
                        [/\/\*/, 'comment', '@comment']
                    ],

                    comment: [
                        [/[^/*]+/, 'comment'],
                        [/\*\//, 'comment', '@pop'],
                        [/[/*]/, 'comment']
                    ],

                    // Value can be: string, number, bool, null, object, array, or interpolation
                    value: [
                        [/\$\{/, { token: 'delimiter.bracket.interpolation', next: '@interpolation', nextEmbedded: 'javascript' }],
                        [/"/, 'string', '@string'],
                        [/-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/, 'number'],
                        [/true|false/, 'keyword'],
                        [/null/, 'keyword'],
                        [/[{]/, 'delimiter.bracket', '@object'],
                        [/\[/, 'delimiter.bracket', '@array']
                    ],

                    // Object: handles keys (strings), colons, commas, values
                    object: [
                        { include: '@whitespace' },
                        [/:/, 'delimiter'],
                        [/,/, 'delimiter'],
                        { include: '@value' },
                        [/\}/, 'delimiter.bracket', '@pop']
                    ],

                    // Array: handles commas and values
                    array: [
                        { include: '@whitespace' },
                        [/,/, 'delimiter'],
                        { include: '@value' },
                        [/\]/, 'delimiter.bracket', '@pop']
                    ],

                    // String with interpolation support
                    string: [
                        [/\$\{/, { token: 'delimiter.bracket.interpolation', next: '@interpolationInString', nextEmbedded: 'javascript' }],
                        [/[^"\\$]+/, 'string'],
                        [/@escapes/, 'string.escape'],
                        [/\\./, 'string.escape.invalid'],
                        [/\$(?!\{)/, 'string'],
                        [/"/, 'string', '@pop']
                    ],

                    // Standalone interpolation (as a value)
                    interpolation: [
                        [/\}/, { token: 'delimiter.bracket.interpolation', next: '@pop', nextEmbedded: '@pop' }]
                    ],

                    // Interpolation inside a string
                    interpolationInString: [
                        [/\}/, { token: 'delimiter.bracket.interpolation', next: '@pop', nextEmbedded: '@pop' }]
                    ]
                }
            });

            // Set up JavaScript defaults and extra libs for variable completions inside ${}
            // This must be done before the worker is used
            monaco.languages.typescript.javascriptDefaults.setCompilerOptions({
                allowNonTsExtensions: true,
                allowJs: true,
                checkJs: false,
                noLib: true,
                target: monaco.languages.typescript.ScriptTarget.ESNext
            });

            monaco.languages.typescript.javascriptDefaults.setExtraLibs([
                {
                    content: `
/** The name to greet */
declare const name: string;
/** Current environment */
declare const env: string;
/** Application configuration */
declare const config: { debug: boolean; port: number };
/** Base API URL */
declare const API_URL: string;
/** Application version */
declare const VERSION: string;

/** Format a date to string */
declare function formatDate(date: Date): string;
/** Capitalize a string */
declare function capitalize(str: string): string;
`,
                    filePath: 'file:///globals.d.ts'
                }
            ]);

            // Create a dummy JS model to initialize the JavaScript worker
            // This ensures the worker is ready when we need it
            const dummyModel = monaco.editor.createModel('', 'javascript');
            dummyModel.dispose();

            // --- Virtual model for JavaScript completions ---
            const VIRTUAL_JS_URI = monaco.Uri.parse('file:///interpolation-expr.js');
            let virtualJsModel = null;

            function getOrCreateVirtualJsModel() {
                if (!virtualJsModel || virtualJsModel.isDisposed()) {
                    virtualJsModel = monaco.editor.createModel('', 'javascript', VIRTUAL_JS_URI);
                }
                return virtualJsModel;
            }

            // --- Helper to flatten tokens into absolute offsets ---
            function flattenTokens(model) {
                const source = model.getValue();
                const tokenLines = monaco.editor.tokenize(source, LANGUAGE_ID);
                const tokens = [];

                let currentOffset = 0;
                for (let lineIdx = 0; lineIdx < tokenLines.length; lineIdx++) {
                    const lineTokens = tokenLines[lineIdx];
                    const lineContent = model.getLineContent(lineIdx + 1);

                    for (let tokenIdx = 0; tokenIdx < lineTokens.length; tokenIdx++) {
                        const token = lineTokens[tokenIdx];
                        const nextToken = lineTokens[tokenIdx + 1];
                        const startOffset = currentOffset + token.offset;
                        const endOffset = nextToken
                            ? currentOffset + nextToken.offset
                            : currentOffset + lineContent.length;

                        tokens.push({ startOffset, endOffset, type: token.type });
                    }
                    currentOffset += lineContent.length + 1; // +1 for newline
                }
                return tokens;
            }

            // --- Helper to extract interpolation context using tokenization ---
            function getInterpolationContext(model, position) {
                const tokens = flattenTokens(model);
                const text = model.getValue();
                const offset = model.getOffsetAt(position);

                // Find the token at the current offset
                let currentTokenIdx = -1;
                for (let i = 0; i < tokens.length; i++) {
                    const token = tokens[i];
                    if (offset >= token.startOffset && offset <= token.endOffset) {
                        currentTokenIdx = i;
                        break;
                    }
                }

                if (currentTokenIdx === -1) return null;

                const currentToken = tokens[currentTokenIdx];

                // Check if we're in an embedded JavaScript region
                // Embedded JS tokens don't have the .json-interpolation postfix
                const isInEmbeddedJs = !currentToken.type.endsWith('.json-interpolation') && currentToken.type !== '';

                if (!isInEmbeddedJs) {
                    // Also check if we're right after the ${ delimiter
                    if (currentToken.type === 'delimiter.bracket.interpolation.json-interpolation') {
                        const tokenText = text.substring(currentToken.startOffset, currentToken.endOffset);
                        if (tokenText === '${' && offset === currentToken.endOffset) {
                            // Cursor is right after ${, find the closing }
                            for (let i = currentTokenIdx + 1; i < tokens.length; i++) {
                                if (tokens[i].type === 'delimiter.bracket.interpolation.json-interpolation') {
                                    const expressionStart = currentToken.endOffset;
                                    const expressionEnd = tokens[i].startOffset;
                                    return {
                                        expression: text.substring(expressionStart, expressionEnd),
                                        expressionStart,
                                        expressionEnd,
                                        offsetInExpression: offset - expressionStart
                                    };
                                }
                            }
                        }
                    }
                    return null;
                }

                // Walk backwards to find the ${ delimiter
                let interpolationStartOffset = -1;
                for (let i = currentTokenIdx - 1; i >= 0; i--) {
                    const token = tokens[i];
                    if (token.type === 'delimiter.bracket.interpolation.json-interpolation') {
                        const tokenText = text.substring(token.startOffset, token.endOffset);
                        if (tokenText === '${') {
                            interpolationStartOffset = token.endOffset;
                            break;
                        }
                    }
                }

                if (interpolationStartOffset === -1) return null;

                // Walk forwards to find the closing } delimiter
                let interpolationEndOffset = -1;
                for (let i = currentTokenIdx + 1; i < tokens.length; i++) {
                    const token = tokens[i];
                    if (token.type === 'delimiter.bracket.interpolation.json-interpolation') {
                        interpolationEndOffset = token.startOffset;
                        break;
                    }
                }

                if (interpolationEndOffset === -1) {
                    interpolationEndOffset = text.length;
                }

                const expression = text.substring(interpolationStartOffset, interpolationEndOffset);
                return {
                    expression,
                    expressionStart: interpolationStartOffset,
                    expressionEnd: interpolationEndOffset,
                    offsetInExpression: offset - interpolationStartOffset
                };
            }

            // --- Completion provider for JS inside interpolation ---
            monaco.languages.registerCompletionItemProvider(LANGUAGE_ID, {
                triggerCharacters: ['"', ':', ' ', '$', '{', '.'],

                async provideCompletionItems(model, position) {
                    const ctx = getInterpolationContext(model, position);
                    if (!ctx) return null;

                    try {
                        // Create/update virtual JS model with just the expression
                        const jsModel = getOrCreateVirtualJsModel();
                        jsModel.setValue(ctx.expression);

                        const getWorker = await monaco.languages.typescript.getJavaScriptWorker();
                        const worker = await getWorker(VIRTUAL_JS_URI);
                        const info = await worker.getCompletionsAtPosition(
                            VIRTUAL_JS_URI.toString(),
                            ctx.offsetInExpression
                        );

                        if (!info || !info.entries) return null;

                        const wordInfo = model.getWordUntilPosition(position);
                        const range = {
                            startLineNumber: position.lineNumber,
                            startColumn: wordInfo.startColumn,
                            endLineNumber: position.lineNumber,
                            endColumn: wordInfo.endColumn
                        };

                        const suggestions = info.entries.map(entry => ({
                            label: entry.name,
                            kind: monaco.languages.CompletionItemKind.Variable,
                            detail: entry.kindModifiers,
                            sortText: entry.sortText,
                            insertText: entry.insertText || entry.name,
                            range: range
                        }));

                        return { suggestions };
                    } catch (e) {
                        console.error('JS completion error:', e);
                    }
                    return null;
                }
            });

            // --- Hover provider for JS inside interpolation ---
            monaco.languages.registerHoverProvider(LANGUAGE_ID, {
                async provideHover(model, position) {
                    const ctx = getInterpolationContext(model, position);
                    if (!ctx) return null;

                    try {
                        // Create/update virtual JS model with just the expression
                        const jsModel = getOrCreateVirtualJsModel();
                        jsModel.setValue(ctx.expression);

                        const getWorker = await monaco.languages.typescript.getJavaScriptWorker();
                        const worker = await getWorker(VIRTUAL_JS_URI);
                        const info = await worker.getQuickInfoAtPosition(
                            VIRTUAL_JS_URI.toString(),
                            ctx.offsetInExpression
                        );

                        if (!info) return null;

                        const contents = [];
                        if (info.displayParts) {
                            const displayText = info.displayParts.map(p => p.text).join('');
                            contents.push({ value: '```typescript\n' + displayText + '\n```' });
                        }
                        if (info.documentation && info.documentation.length > 0) {
                            const docText = info.documentation.map(p => p.text).join('');
                            contents.push({ value: docText });
                        }

                        if (contents.length === 0) return null;

                        const wordInfo = model.getWordAtPosition(position);
                        const range = wordInfo ? {
                            startLineNumber: position.lineNumber,
                            startColumn: wordInfo.startColumn,
                            endLineNumber: position.lineNumber,
                            endColumn: wordInfo.endColumn
                        } : undefined;

                        return { contents, range };
                    } catch (e) {
                        console.error('JS hover error:', e);
                    }
                    return null;
                }
            });

            // --- Sample JSON content with interpolation ---
            const sampleContent = `{
  // This is a JSON file with interpolation support
  "greeting": "Hello, \${name}!",
  "environment": "\${env}",
  "apiEndpoint": "\${API_URL}/users",
  "version": "\${VERSION}",

  /* Multi-line comment support */
  "settings": {
    "debug": \${config.debug},
    "port": \${config.port}
  },

  // Try typing inside \${} to see JavaScript completions
  "computed": "\${capitalize(name)}",

  // Trailing commas are allowed
  "items": [1, 2, 3,],
}`;

            // Create the editor
            const editor = monaco.editor.create(document.getElementById('container'), {
                value: sampleContent,
                language: LANGUAGE_ID,
                theme: 'vs-dark',
                minimap: { enabled: false },
                automaticLayout: true,
                fontSize: 14,
                tabSize: 2
            });

            console.log('JSON Interpolation editor initialized');
            console.log('Try:');
            console.log('  - Hover over ${name} to see variable info');
            console.log('  - Type inside ${} to get JavaScript completions');
            console.log('  - Notice syntax highlighting for embedded JS');
        });
    </script>
</body>
</html>
